"use strict";(self.webpackChunkanyshake_org=self.webpackChunkanyshake_org||[]).push([[1887],{1032:(e,n,i)=>{i.d(n,{A:()=>t});const t=i.p+"assets/files/download-metadata-7a2d65a3e1f84dbe925a817cd1c8919c.webp"},28453:(e,n,i)=>{i.d(n,{R:()=>a,x:()=>o});var t=i(96540);const s={},r=t.createContext(s);function a(e){const n=t.useContext(r);return t.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:a(e.components),t.createElement(r.Provider,{value:n},e.children)}},49730:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>l,contentTitle:()=>o,default:()=>h,frontMatter:()=>a,metadata:()=>t,toc:()=>c});const t=JSON.parse('{"id":"applications/get-accelerations","title":"Get Accelerations from AnyShake","description":"At present, AnyShake Explorer outputs raw sample values (counts) directly acquired from the ADC and accelerometer. It does not output pre-scaled physical quantities such as velocity or acceleration.","source":"@site/docs/applications/get-accelerations.md","sourceDirName":"applications","slug":"/applications/get-accelerations","permalink":"/docs/applications/get-accelerations","draft":false,"unlisted":false,"editUrl":"https://github.com/anyshake/homepage/blob/master/docs/applications/get-accelerations.md","tags":[],"version":"current","sidebarPosition":1,"frontMatter":{"sidebar_position":1,"title":"Get Accelerations from AnyShake","slug":"get-accelerations"},"sidebar":"tutorialSidebar","previous":{"title":"Applications","permalink":"/docs/category/applications"},"next":{"title":"Station Trigger with NodeRED","permalink":"/docs/applications/station-trigger-nodered"}}');var s=i(74848),r=i(28453);const a={sidebar_position:1,title:"Get Accelerations from AnyShake",slug:"get-accelerations"},o=void 0,l={},c=[{value:"Obtaining Station Metadata",id:"obtaining-station-metadata",level:2},{value:"Obtaining Waveform Data",id:"obtaining-waveform-data",level:2},{value:"Computing Engineering Metrics",id:"computing-engineering-metrics",level:2},{value:"Requirements",id:"requirements",level:3},{value:"Example Script",id:"example-script",level:3},{value:"Notes",id:"notes",level:3}];function d(e){const n={a:"a",admonition:"admonition",code:"code",em:"em",h2:"h2",h3:"h3",img:"img",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,r.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsxs)(n.p,{children:["At present, ",(0,s.jsx)(n.strong,{children:"AnyShake Explorer outputs raw sample values (counts)"})," directly acquired from the ADC and accelerometer. It does ",(0,s.jsx)(n.strong,{children:"not"})," output pre-scaled physical quantities such as velocity or acceleration."]}),"\n",(0,s.jsxs)(n.p,{children:["Therefore, engineering metrics such as ",(0,s.jsx)(n.strong,{children:"PGA"})," (Peak Ground Acceleration) and ",(0,s.jsx)(n.strong,{children:"PGV"})," (Peak Ground Velocity) must be derived during post-processing, where unit conversion, instrument response removal, and appropriate filtering can be applied in a controlled and reproducible manner."]}),"\n",(0,s.jsxs)(n.admonition,{title:"Why not output pre-scaled physical units directly",type:"info",children:[(0,s.jsxs)(n.p,{children:["AnyShake Explorer intentionally outputs ",(0,s.jsx)(n.strong,{children:"raw sensor counts"})," rather than pre-scaled physical units for the following reasons:"]}),(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Preserve data fidelity"}),": Raw counts retain the complete information produced by the ADC and sensor, without irreversible scaling or rounding."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Ensure reproducibility"}),": Physical units depend on gain, response models, filters, and assumptions. Performing these steps offline makes the entire processing chain explicit and repeatable."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Separation of concerns"}),": AnyShake Explorer focuses strictly on ",(0,s.jsx)(n.em,{children:"data acquisition"}),". Signal interpretation, unit conversion, and engineering metrics are handled at the software layer."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Auditability and flexibility"}),": Users can independently verify, modify, or replace processing parameters (e.g., response models, filters, integration methods) without firmware changes."]}),"\n"]}),(0,s.jsx)(n.p,{children:"This design follows common practice in professional seismology and strong-motion instrumentation workflows."})]}),"\n",(0,s.jsx)(n.h2,{id:"obtaining-station-metadata",children:"Obtaining Station Metadata"}),"\n",(0,s.jsxs)(n.p,{children:["Key parameters such as system gain, sensor response (poles and zeros), channel definitions, and sampling rate are fully defined in the ",(0,s.jsx)(n.strong,{children:"station metadata"}),". By loading and parsing this metadata during post-processing, raw sample counts can be accurately converted into physical quantities such as acceleration, velocity, or displacement."]}),"\n",(0,s.jsxs)(n.p,{children:["The station metadata is provided as an XML file and can be downloaded from the ",(0,s.jsx)(n.strong,{children:"Settings"})," page in AnyShake Explorer:"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.a,{target:"_blank","data-noBrokenLinkCheck":!0,href:i(1032).A+"",children:"Download Metadata"})}),"\n",(0,s.jsx)(n.p,{children:"Two formats are supported:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"SeisComP XML"}),": The native metadata format used by the SeisComP system, which is widely deployed in professional seismic networks."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"FDSN StationXML"}),": An international standard defined by the International Federation of Digital Seismograph Networks (FDSN). It is the most widely supported metadata exchange format in the seismological community."]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["By default, the format is ",(0,s.jsx)(n.strong,{children:"SeisComP XML"}),". After downloading, place the metadata file in the ",(0,s.jsx)(n.strong,{children:"same directory"})," as the waveform data files to be processed."]}),"\n",(0,s.jsx)(n.h2,{id:"obtaining-waveform-data",children:"Obtaining Waveform Data"}),"\n",(0,s.jsxs)(n.p,{children:["Navigate to the ",(0,s.jsx)(n.strong,{children:"History Waveform"})," page and select the time range of interest. Then download the MiniSEED files for each channel."]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.img,{alt:"Download Waveform",src:i(81364).A+"",width:"1910",height:"829"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["For geophone channels, select the following channels:","\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"EHZ"})," (Vertical)"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"EHE"})," (East\u2013West)"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"EHN"})," (North\u2013South)"]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["For accelerometer channels, select the following channels:","\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"ENZ"})," (Vertical)"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"ENE"})," (East\u2013West)"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"ENN"})," (North\u2013South)"]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"After downloading, place all waveform files in the same directory as the station metadata file."}),"\n",(0,s.jsx)(n.admonition,{title:"Time Alignment",type:"warning",children:(0,s.jsxs)(n.p,{children:["When computing three-component vector quantities (PGA / PGV / PGD), the start time, end time, and sampling rate of all three components ",(0,s.jsx)(n.strong,{children:"must be identical"}),". AnyShake Explorer ensures time alignment during export, but if the data are manually trimmed or merged, this should be verified again."]})}),"\n",(0,s.jsx)(n.h2,{id:"computing-engineering-metrics",children:"Computing Engineering Metrics"}),"\n",(0,s.jsxs)(n.p,{children:["The following example demonstrates a complete processing workflow using ",(0,s.jsx)(n.strong,{children:"ObsPy"}),", including:"]}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsx)(n.li,{children:"Reading and merging waveform data"}),"\n",(0,s.jsx)(n.li,{children:"Detrending, demeaning, and tapering"}),"\n",(0,s.jsx)(n.li,{children:"Instrument response removal (counts \u2192 physical units)"}),"\n",(0,s.jsx)(n.li,{children:"Bandpass filtering"}),"\n",(0,s.jsx)(n.li,{children:"Three-component vector composition"}),"\n",(0,s.jsx)(n.li,{children:"Calculation of PGA, PGV, and PGD"}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"requirements",children:"Requirements"}),"\n",(0,s.jsx)(n.p,{children:"Ensure the following are installed:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Python \u2265 3.8"}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.code,{children:"numpy"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.code,{children:"obspy"})}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"example-script",children:"Example Script"}),"\n",(0,s.jsxs)(n.p,{children:["Copy the script below, modify ",(0,s.jsx)(n.code,{children:"FILES"})," and ",(0,s.jsx)(n.code,{children:"CHANNELS"})," to match your data, and save it as ",(0,s.jsx)(n.code,{children:"get_metrics.py"}),"."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:'# -*- coding: utf-8 -*-\nfrom obspy import Stream, read, read_inventory\nfrom numpy import max, abs, sqrt\n\n\ndef main():\n    INVENTORY = read_inventory("./seiscomp_xml.xml")\n    FILES = [\n        "./2025.358.09.42.23.0003.SHAKE.AS.00.EHE.D.mseed",\n        "./2025.358.09.42.23.0003.SHAKE.AS.00.EHZ.D.mseed",\n        "./2025.358.09.42.23.0003.SHAKE.AS.00.EHN.D.mseed",\n    ]\n    CHANNELS = ["EHE", "EHN", "EHZ"]\n    BANDPASS = dict(freqmin=0.1, freqmax=10.0)\n\n    raw_data = Stream()\n    for f in FILES:\n        raw_data += read(f, format="mseed")\n    raw_data.merge(fill_value="interpolate")\n\n    processed_data = {"ACC": {}, "VEL": {}, "DISP": {}}\n    for i, component in enumerate(CHANNELS):\n        for unit in processed_data.keys():\n            data_copy = raw_data[i].copy()\n            data_copy.detrend("linear")\n            data_copy.detrend("demean")\n            data_copy.taper(max_percentage=0.05, type="cosine")\n            data_copy.remove_response(\n                inventory=INVENTORY,\n                output=unit,\n            )\n            data_copy.filter("bandpass", **BANDPASS)\n            processed_data[unit][component] = data_copy.data * 100\n\n    results = {}\n    for key in processed_data.keys():\n        value_arr = []\n        for idx, _ in enumerate(processed_data[key][CHANNELS[0]]):\n            val = 0\n            for comp in CHANNELS:\n                val += (processed_data[key][comp][idx] ** 2)\n            value_arr.append(sqrt(abs(val)))\n        results[key] = max(value_arr)\n\n    print(">>> Peak Ground Motion (3-Component Vector Sum)")\n    print(f"PGA  (cm/s/s): {results[\'ACC\']:.4f}")\n    print(f"PGV  (cm/s)  : {results[\'VEL\']:.4f}")\n    print(f"PGD  (cm)    : {results[\'DISP\']:.4f}")\n\n\nif __name__ == "__main__":\n    main()\n'})}),"\n",(0,s.jsx)(n.p,{children:"Run the script:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-bash",children:"$ python get_metrics.py\n"})}),"\n",(0,s.jsx)(n.p,{children:"It will output the PGA, PGV, and PGD values in centimeters."}),"\n",(0,s.jsx)(n.h3,{id:"notes",children:"Notes"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"remove_response()"})," outputs values in ",(0,s.jsx)(n.strong,{children:"SI units"}),". The example converts results to ",(0,s.jsx)(n.strong,{children:"centimeter-based units"})," for engineering convenience."]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:"Bandpass filter parameters should be adjusted based on application, such as:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Strong-motion engineering"}),"\n",(0,s.jsx)(n.li,{children:"Structural response analysis"}),"\n",(0,s.jsx)(n.li,{children:"Long-period ground motion studies"}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:"PGA / PGV / PGD are computed as the maximum of the instantaneous three-component vector magnitude: \u221a(E\xb2 + N\xb2 + Z\xb2)"}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:"For PGD (displacement), the low-frequency cutoff is critical; improper filtering may introduce significant drift."}),"\n"]}),"\n"]})]})}function h(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(d,{...e})}):d(e)}},81364:(e,n,i)=>{i.d(n,{A:()=>t});const t=i.p+"assets/images/download-waveform-20f4051d294c447720f9b0ee2d4f762c.webp"}}]);